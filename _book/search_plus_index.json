{"./":{"url":"./","title":"introduction","keywords":"","body":"搞着玩 "},"FrontEnd/CSS/":{"url":"FrontEnd/CSS/","title":"CSS","keywords":"","body":"CSS 水平居中 元素为行内元素，设置父元素 text-align:center. 元素宽度固定，可设置 margin:auto。 元素为绝对定位，设置父元素为 position:relative，元素设置 left:0;right:0;margin:auto。 使用 flex-box 布局，指定 justify-content:center。 元素设置 display:table-ceil。 垂直居中 - "},"FrontEnd/Javascript/":{"url":"FrontEnd/Javascript/","title":"JavaScript","keywords":"","body":"JavaScript "},"FrontEnd/Javascript/EventAttemper.html":{"url":"FrontEnd/Javascript/EventAttemper.html","title":"事件调度","keywords":"","body":"事件调度 JS 单线程 浏览器中负责解释和执行 javascript 代码的只有一个线程 浏览器渲染进程 js 引擎线程 - 维护执行栈 事件触发线程 - 维护消息队列 定时触发器线程 异步Http请求线程 GUI渲染线程 事件循环 执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务。 宏任务（macroTask） 一个宏任务执行完后，会在执行下一个宏任务之前 先执行为任务队列 主代码块 定时器任务 微任务（microTask） 微任务队列执行完，GUI线程接管进行渲染，渲染完成后进行下一个宏任务 Promise process.nextTick "},"FrontEnd/Javascript/iterator.html":{"url":"FrontEnd/Javascript/iterator.html","title":"迭代器 Iterator & 异步迭代器","keywords":"","body":"迭代器Iterator & 异步迭代器 迭代器 任何一个对象。含有返回值为{done:true/false,value:xxx}的 next()函数 就认为是一个迭代器为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署 Iterator ，就可以完成遍历操作ES6 规定，一个数据只要具有 Symbol.iterator 属性并且返回符合迭代器协议的对象时，就可以认为是“可遍历的” Symbol.iterator 是一个表达式，返回 Symbol 对象的 iterator 属性，是一个预定好的，类型为 Symbol 的特殊值。原生数据默认部署的有： Array Map Set String TypedArray 可迭代协议 允许 Javascript 对象去定义或定制它们的迭代行为 迭代器协议 定义了一种标准的方式来产生一个有限或无限序列的值，并且当所有的值都已经被迭代后，就会有一个默认的返回值。 当一个对象满足下述条件才会被认为是一个迭代器 实现了一个 next() 方法并且拥有以下含义 遍历过程 创建一个指针对象，指向当前数据结构的起始位置 不断调用指针对象的 next 方法，每次调用都会返回数据结构的当前成员的信息 遍历- for...of... 异步迭代器 区别于 同步迭代器 的next 方法返回含有 value 和 done 属性的对象，而 异步迭代器 的 next 方法返回一个Promise 对象，并且 Promise 对象的值为含有 value 和 done 属性的对象 遍历- for...await...of "},"FrontEnd/Javascript/generator.html":{"url":"FrontEnd/Javascript/generator.html","title":"生成器 Generator & 异步生成器","keywords":"","body":"生成器 Generator & 异步生成器 生成器 生成器对象是一个由 generator function 返回的，并且它符合可迭代协议和迭代器协议 生成器函数在执行时能暂时暂停，后面从暂停处继续执行 Generator.prototype.next() 返回一个由 yield 表达式生成的值 Generator.prototype.return() 返回给定的值并结束生成器 Generator.prototype.throw() 向生成器抛出一个错误 function* 定义一个生成器函数，返回一个 Generator 对象 异步生成器 异步生成器和普通的生成器很像，但是其是 async 函数，内部可以使用 await 表达式，并且它返回一个具有 Symbol.asyncIterator 方法的对象。 "},"FrontEnd/Javascript/es7.html":{"url":"FrontEnd/Javascript/es7.html","title":"ES7","keywords":"","body":"ES7 includes() 用于判断一个数组是否包含一个指定的值，如果包含则返回 true ，否则返回 false 。 // includes 和 indexOf 相似 let arr = [1, 2, 3, 4, 5, 6]; let x = 2; // 判断是否包含某值x = 2 // es7之前 arr.indexOf(x) !== -1; // true // es7之后 arr.includes(x); // true arr.includes(2); // true 指数操作符 ** 指数运算符 ** ,具有和 Math.pow(..) 等效的计算效果 Math.pow(8, 2); // 64 8 ** 2; // 64 "},"FrontEnd/Javascript/es8.html":{"url":"FrontEnd/Javascript/es8.html","title":"ES8","keywords":"","body":"ES8 async/await 异步函数,返回 Promise // 不使用 async/await let login = function() { $.ajax({ url: \"xxx\" }).then(() => { getUserInfo(); }); }; let getUserInfo = function() { // 获取用户信息 }; login(); // 实现功能：登录后获取用户信息 // 使用 async/await let asyncLogin = async function() { await $.ajax(); // 登录； $.ajax(); // 获取用户信息； }; Object.values 返回 Object 自身属性的所有值，不包括继承的值 let object1 = { name: \"object1\", desc: \"美丽的Object\" }; let object2 = Object.create(object1); object2.aliasName = \"帅气的object2\"; console.log(object2.name); // 'object1' 继承的值 console.log(object2.desc); // '美丽的Object' 继承的值 console.log(object2.aliasName); // '帅气的object2' Object.values(object2); // ['帅气的object2'] Object.entries 返回指定对象自身可枚举属性的键值对的数组 let object3 = { value: \"调皮的object3\" }; Object.definedProperty(object3, \"name\", { value: \"object3\", // 属性对应的值，默认为undefined writable: false, // 为true时才能被赋值运算符改变，默认为false enumerable: false, // 为true时，此属性才会出现在枚举属性中，默认false configurable: true // 为true时，该属性描述符才能够改变，同时该属性也能从对应的对象上被删掉，默认false }); let dealData = Object.entries(object3); console.log(dealData); // [['value','调皮的object3']] console.log(object3.name); // 'object3' String.prototype.padStart 用另一个字符串填充当前字符串（重复，如果需要），以便产生的字符串达到给定的长度，填充从当前字符串的左侧开始。 \"abc\".padStart(10, \"333\"); // '3333333abc' \"abc\".padStart(10); // ' abc' \"abc\".padStart(10, \"efaghsgdtrifbdk\"); // 'efaghsgabc' String.prototype.padEnd 用另一个字符串填充当前字符串（重复，如果需要），以便产生的字符串达到给定的长度，填充从当前字符串的右侧开始。 \"abc\".padEnd(10, \"333\"); // 'abc3333333' \"abc\".padEnd(10); // 'abc ' \"abc\".padEnd(10, \"efaghsgdtrifbdk\"); // 'abcefaghsg' Object.getOwnPropertyDesciptors 方法返回指定对象上一个自有属性对应的属性描述符 let object4 = { name: \"object4\" }; Object.getOwnPropertyDescriptor(object4, \"name\"); // { // value:'object4', // configurable:true, // writable:true, // enumerable:true, // } 函数参数列表允许结尾处逗号 let fn = function(a, b) {}; "},"FrontEnd/Javascript/es9.html":{"url":"FrontEnd/Javascript/es9.html","title":"ES9","keywords":"","body":"ES9 异步迭代器 & for...await...of for...of 方法能够遍历具有 Symbol.iterator 接口的 同步迭代器 数据。for...await...of 方法能够遍历具有 Symbol.asyncIteratore 接口的 异步迭代器 数据。即当前一个成员状态改变后，才会遍历到下一个成员 var arrayList = [1, 2, 3, 4, 5, 6, 7]; // 异步迭代器 arrayList[Symbol.asyncIterator] = function() { const len = this.length; let pointer = 0; return { next: function() { const done = pointer >= len; const value = done ? undefined : arrayList[pointer++]; return new Promise(function(resolve, reject) { setTimeout(() => { resolve({ value, done }); }, 1000); }); } }; }; // 遍历异步迭代器 var traverse1 = async function(array) { for await (let i of array) { console.log(i); } }; traverse1(arrayList); // 每隔1秒输出一个 // 遍历同步迭代器 var traverse2 = function(array) { for (let i of array) { console.log(i); } }; traverse2(arrayList); // 一起输出 正则表达式命名捕获组 允许命名捕获组使用符号 ? ，在打开捕获括号 ( 后立即命名 任何匹配失败的命名组都将返回 undefined // before const reDate = /([0-9]{4})-([0-9]{2})-([0-9]{2})/, match = reDate.exec(\"2018-04-30\"), year = match[1], // 2018 month = match[2], // 04 day = match[3]; // 30 // now const reDate = /(?[0-9]{4})-(?[0-9]{2})-(?[0-9]{2})/, match = reDate.exec(\"2018-04-30\"), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 // 也可用于 replace const reDate = /(?[0-9]{4})-(?[0-9]{2})-(?[0-9]{2})/, d = \"2018-04-30\", usDate = d.replace(reDate, \"$-$-$\"); // '04-30-2018' 正则表达式反向断言 // 目前js 支持先行断言 // 匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中 const reLookahead = /\\D(?=\\d+)/, match = reLookahead.exec(\"$123.89\"); console.log(match[0]); // $ "},"FrontEnd/Javascript/regexp/":{"url":"FrontEnd/Javascript/regexp/","title":"正则表达式","keywords":"","body":"正则表达式 "},"FrontEnd/Javascript/regexp/duanYan.html":{"url":"FrontEnd/Javascript/regexp/duanYan.html","title":"断言","keywords":"","body":"断言 正则位置匹配 了解概念 零度：只匹配位置，在匹配过程中，不占用字符，所以被称为零度。 先行：正则引擎在扫描字符的时候，从左往右扫描，匹配扫描指针未扫描过的字符，先于指针，称之先行。 后行：匹配指针已扫描过的字符，后于指针到达该字符，称之后行，即产生回溯。 正向：即匹配括号中的表达式 负向：不匹配括号中的表达式 先行断言 es5 开始支持 零度正向先行断言 又称正向向前查找 `sinM.`.match(/sin(?=M\\.)/g); // [\"sin\"] `M.sin`.match(/sin(?=M\\.)/g); // null 后行断言 es9 开始支持 零度负向先行断言 又称负向向前查找 `M.sin`.match(/sin(?!M\\.)/g); // [\"sin\"] `sinM.`.match(/sin(?!M\\.)/g); // null "},"FrontEnd/Javascript/kuoYu.html":{"url":"FrontEnd/Javascript/kuoYu.html","title":"前端跨域","keywords":"","body":"前端跨域 跨域并非限制浏览器请求，而是返回结果被浏览器拦截 JSONP JSON with Padding 页面上引入不同域上的 js 脚本文件是被允许。 回调函数：响应到来时在页面中调用的函数 数据：传入回调函数中的 JSON 数据 CROS（Cross-Origin Resource Sharing）跨域资源共享 定义了访问跨域资源时，浏览器与服务器应该如何沟通。基本思想：使用自定义 http 头部，让服务器能声明哪些来源可以通过浏览器访问该服务器上的资源，从而决定请求或响应时应该成功还是失败。CORS 本身并非绝对安全，可用 OAuth2 措施来加强保障 Access-Control-Allow-Origin *：允许任何域接收响应 指定域名：指定域可接收响应 documemt.domain/iframe（跨子域） 同源策略限制不用域中的 js 数据交互 domain：设置相同域，主域必须相同 window.name 在一个窗口的生命周期内，窗口载入的所有页面都共享一个 window.name，每个页面对 window.name 都有读写的权限。window.name 是持久存在一个窗口载入过的所有页面中 window.postMessage Html5 新特性 可使用向其他的 windows 对象发送消息 "},"FrontEnd/Javascript/Bold.html":{"url":"FrontEnd/Javascript/Bold.html","title":"Bolb","keywords":"","body":"Bolb 表示一个不可变的，原始数据的类文件对象。File 接口基于 Blob const blob1 = new Blob([\"123456\"]); const blob2 = blob1.slice(1, 4); const fileRead = new FileReader(); const blob2Content1 = fileRead.readAsBinaryString(blob2); console.log(fileRead.result); // '2345' const blob2Content2 = fileRead.readAsArrayBuffer(blob2); // 暂不懂可干嘛 const blob2Content3 = fileRead.readAsArrayBuffer(blob2); console.log(fileRead.result); // 返回结果链接 Blob.size（只读）：Blob 对象所包含的数据的大小 const objectDemo = { a: 1 }; const blob3 = new Blob([JSON.stringify(objectDemo)]); console.log(blob3.size); // 7 => {\"a\":1} => 7 const blob4 = new Blob([objectDemo]); console.log(blob4.size); // 15 => [object Object] => 15 // 使用普通对象创建 Blob 时，相当于调用了普通对象的 toString()的方法得到字符串数据，然后在创建 Blob "},"FrontEnd/StateManage/":{"url":"FrontEnd/StateManage/","title":"状态管理","keywords":"","body":"状态管理 "},"FrontEnd/StateManage/Mobx/":{"url":"FrontEnd/StateManage/Mobx/","title":"Mobx","keywords":"","body":"Mobx "},"FrontEnd/StateManage/ReactRedux/":{"url":"FrontEnd/StateManage/ReactRedux/","title":"ReactRedux","keywords":"","body":"intro "},"FrontEnd/StateManage/ReactRedux/Provider.html":{"url":"FrontEnd/StateManage/ReactRedux/Provider.html","title":"Provider","keywords":"","body":"Provider 使得Redux store可用于connect()函数中包装的任何嵌套组件 "},"FrontEnd/StateManage/ReactRedux/ReactRudex.html":{"url":"FrontEnd/StateManage/ReactRedux/ReactRudex.html","title":"版本要求","keywords":"","body":"版本要求 7.1 - React 16.8.3 !7.0 - React 16.0 6.x - React 16.0 muji版本 批售版本 v6.0.12 react:v16.4.0{ \"name\": \"@souche-f2e/muji\", \"version\": \"0.2.6\", \"description\": \"\", \"main\": \"lib/index.js\", \"module\": \"lib/index.js\", \"types\": \"src/typings/index.d.ts\", \"files\": [ \"src\", \"lib\" ], \"author\": \"souche-f2e\", \"scripts\": { \"dev\": \"rimraf lib && tsc -w\", \"build\": \"rimraf lib && tsc\", \"prepare\": \"npm run build\", \"postinstall\": \"PATH=$PATH:./node_modules/.bin/ node -e \\\"try{require('child_process').execSync('npm-statistics')}catch(err){};require('process').exit(0);\\\"\" }, \"dependencies\": { \"@souche-f2e/muji-router\": \"^0.2.6\", \"@souche-f2e/muji-store\": \"^0.2.6\", \"@souche-f2e/npm-statistics\": \"latest\", \"axios\": \"^0.18.0\", \"deepmerge\": \"^3.2.0\", \"lodash.defaultsdeep\": \"^4.6.0\", \"react\": \"^16.4.0\", \"react-dom\": \"^16.4.0\", \"react-redux\": \"^6.0.0\", \"redux\": \"^4.0.0\", \"tslib\": \"^1.9.3\" }, \"devDependencies\": { \"@types/enzyme\": \"^3.9.1\", \"@types/hoist-non-react-statics\": \"^3.3.1\", \"@types/invariant\": \"^2.2.29\", \"@types/jest\": \"^24.0.11\", \"@types/lodash\": \"^4.14.123\", \"@types/lodash.defaultsdeep\": \"^4.6.4\", \"@types/react\": \"^16.8.8\", \"@types/react-dom\": \"^16.8.3\", \"@types/react-redux\": \"^6.0.12\", \"@types/react-test-renderer\": \"^16.8.1\", \"@types/webpack-env\": \"^1.13.9\", \"enzyme\": \"^3.9.0\", \"enzyme-adapter-react-16\": \"^1.12.1\", \"enzyme-to-json\": \"^3.3.5\", \"jest\": \"^24.5.0\", \"react-test-renderer\": \"^16.8.5\", \"rimraf\": \"^2.6.2\", \"ts-jest\": \">=24.0.0\", \"typescript\": \"^3.3.4000\" }, \"gitHead\": \"c5ecc3db1d9a4d703929a4e4c6dcd79424a9e9d5\" } 最新版 v7.0.0 react:v16.4.0{ \"name\": \"@souche-f2e/muji\", \"version\": \"0.4.23\", \"description\": \"\", \"main\": \"lib/index.js\", \"module\": \"lib/index.js\", \"types\": \"src/typings/index.d.ts\", \"files\": [ \"src\", \"lib\" ], \"author\": \"souche-f2e\", \"scripts\": { \"dev\": \"rimraf lib && tsc -w\", \"build\": \"rimraf lib && tsc --build tsconfig.json\", \"test\": \"jest\", \"prepare\": \"yarn run build\", \"postinstall\": \"PATH=$PATH:./node_modules/.bin/ node -e \\\"try{require('child_process').execSync('npm-statistics')}catch(err){};require('process').exit(0);\\\"\" }, \"dependencies\": { \"@souche-f2e/npm-statistics\": \"latest\", \"@souche-f2e/path-to-regexp\": \"^1.7.0\", \"axios\": \"^0.18.0\", \"classnames\": \"^2.2.6\", \"deepmerge\": \"^3.2.0\", \"immer\": \"^3.1.3\", \"invariant\": \"^2.2.4\", \"lodash.defaultsdeep\": \"^4.6.0\", \"react\": \"^16.4.0\", \"react-dom\": \"^16.4.0\", \"react-redux\": \"^7.0.0\", \"redux\": \"^4.0.0\", \"tslib\": \"^1.9.3\", \"warning\": \"^4.0.3\" }, \"devDependencies\": { \"@types/classnames\": \"^2.2.8\", \"@types/enzyme\": \"^3.9.1\", \"@types/hoist-non-react-statics\": \"^3.3.1\", \"@types/invariant\": \"^2.2.29\", \"@types/jest\": \"^24.0.11\", \"@types/lodash\": \"^4.14.123\", \"@types/lodash.defaultsdeep\": \"^4.6.4\", \"@types/react\": \"^16.8.8\", \"@types/react-dom\": \"^16.8.3\", \"@types/react-redux\": \"^7.0.0\", \"@types/react-test-renderer\": \"^16.8.1\", \"@types/warning\": \"^3.0.0\", \"@types/webpack-env\": \"^1.13.9\", \"enzyme\": \"^3.9.0\", \"enzyme-adapter-react-16\": \"^1.12.1\", \"enzyme-to-json\": \"^3.3.5\", \"jest\": \"^24.5.0\", \"react-test-renderer\": \"^16.8.5\", \"rimraf\": \"^3.0.0\", \"ts-jest\": \">=24.0.0\", \"typescript\": \"^3.6.2\" }, \"gitHead\": \"69b87fb276306b96948c8a45a9ebbaff652498c6\" } "},"FrontEnd/StateManage/ReactRedux/connect.html":{"url":"FrontEnd/StateManage/ReactRedux/connect.html","title":"connect","keywords":"","body":"connect 将 React 组件连接到 Redux 存储。 它为连接组件提供了存储中所需的数据片段。 不修改连接组件，而是返回一个新的已连接的组件 方法参数 mapStateToProps?: (state, ownProps?) => Object 组件将会监听 Redux store 的变化,任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。如果你省略了这个参数，你的组件将不会监听 Redux store state:redux 提供的状态数据 ownProps:为组件提供的props 参数 仅使用state参数 仅state变化 会调用此函数 同时使用state，ownProps参数 state 和 ownProps 只要有一个变化，都会调用 mapStateToProps 函数。ownProps值为传递到组件的 props。 返回数据 Object 该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。 mapDispatchToProps?: (dispatch,ownProps?) => Object | Object 如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。 参数 Function 该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起 如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。 Object 每个定义在该对象的函数都将被当作 Redux action creator,对象所定义的方法名将作为属性名; import connect from 'XXX/'; const actionFn = ()=>{ return { type:'ACTION_1', text:'此action纯属虚构，如有雷同，嗯，那就是凑巧了。', }; }; const mapDispatchToProps = { callAction:actionFn }; const mapStateToProps = ()=>({}); const A = (props) =>{ return ( { props.callAction(); }} > ... ) }; connect(mapStateToProps,mapDispatchToProps)(A); mergeProps?: (stateProps,dispatchProps,ownProps) => 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。 options?: Object context:object : 供React-Redux使用的自定义上下文 pure:boolean : connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或 state 而只依赖于 props 和 Redux store 的 state。默认值为 true. areStatesEqual?:Function & areOwnPropsEqual?: Function & areStatePropsEqual?: Function & areMergedPropsEqual?: Function 当prue为true时，将传入的state与其之前的值进行比较，指定具体比对值，如果没有改变，connect()会避免重新渲染以及对mapStateToProps、mapDispatchToProps和mergeProps的调用。 forwardRef:boolean :如果指定为true，则像connect包装后的组件添加ref，实际返回被包装组件的实例。 connectAdvanced 是一个将 React 组件连接到 Redux store 的函数 这个函数是 connect() 的基础，但是对于如何把state, props, 和 dispatch 组合到最后的 props 中,则不做定义，完全由调用者操作 不修改连接组件，而是返回一个新的已连接的组件 "},"FrontEnd/StateManage/Redux/":{"url":"FrontEnd/StateManage/Redux/","title":"Redux","keywords":"","body":"Redux "},"FrontEnd/TypeScript/":{"url":"FrontEnd/TypeScript/","title":"TypeScript","keywords":"","body":"typeScript "},"FrontEnd/TypeScript/baseType.html":{"url":"FrontEnd/TypeScript/baseType.html","title":"基础类型","keywords":"","body":"基础类型 布尔值 boolean let isTrue: boolean = false; 数字 number let isNumber: number = 1; // 支持十进制，十六进制，二进制，八进制。 字符串 string let isString: string = \"string\"; // 可使用模版字符串`${}` isString = \"string2\"; 数组 Array [] let isArray: number[] = [1,2,4]; // 元素类型后加[]，表示有此类型元素组成的一个数组 let isArray2: Array = [1,2,4]; // 数组范型：Array 元组 Tuple 元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。let tuple1:[string, number]; tuple1 = ['tuple',1]; // success tuple1 = [1,'tuple']; // error 访问已知索引的元素tuple1[0].substr(1) // success tuple1[1].substr(1) // error number类型没有substr方法 访问越界元素，会使用联合类型替代tuple1[2] = 'tuple1'; // success 越界元素类型可以为string或number( string | number ) tuple1[2] = []; // error []类型不是（ string | number ） 枚举 enum enum 类型是对 JavaScript 标准数据类型的一个补充。 默认从0开始为元素编号，也可以手动指定 提供便利可以由枚举的值得到名字。// 默认编号 enum Color { Red, Green, Blue } let c: Color = Color.Green; // 1 // 指定起始编号 enum Color1 { Red = 1, Green, Blue } let c1: Color1 = Color.Green; // 2 // 指定全部编号 enum Color2 { Red = 1, Green = 3, Blue = 4 } let c2: Color1 = Color.Green; // 3 // 查找相应值的名字 enum Color2 { Red = 1, Green = 3, Blue = 4 } let colorName: string = Color[3]; // 'Green' 任意值 any 为不清楚类型的变量指定一个类型，直接通过编译阶段的检查。并可以调取方法使用。let noType:any = 'any'; noType = []; // success noType = false; // success noType = 1; // success noType.toFixd(2) // success 空值 viod 表示没有任何类型。常见于函数没有返回值 只能赋值 undefined 和 null。let noReturnFn:void = () => { console.log('noReturn'); } // 声明void类型变量 let voidData:void = undefined; // success let voidData:void = null; // success let voidData:void = 1; // error Null null，Undefined undefined 默认情况下 null 和 undefined 是所有类型的子类型，可以赋值给任意类型 当指定 --strictNullChekcs 标记，null 和 undefined 只能赋值给 void 和它们各自 Never never 表示那些永不存在的值的类型。是任何类型的子类型，也可以赋值给任何类型。 没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。即使 any 也不可以赋值给 never。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object object 表示非原始类型：除了 number，string，boolean，symbol，null，undefined 之外的类型 object 类型的变量只允许给他赋值任意值，但只能在它上面调用Object的方法。let c:object = []; c.toString(); // success toString是Object的方法 c.split('_'); // error split不是Object的方法 会报错 c.split is not a function 类型断言 只在编译阶段起作用，告诉编译器类型值let someValue:any = \"this is a any type\"; // TypeScript中使用JSX时，不被允许 let valueLength:number = (someValue).length; // success // TypeScript中使用JSX时，仅有 as 语法断言是被允许的 let valueLength:number = (someValue as string).length; // success "},"FrontEnd/TypeScript/class.html":{"url":"FrontEnd/TypeScript/class.html","title":"类","keywords":"","body":"类 -类实现并实现方法 传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 两部分：静态部分和实例部分。 共有，私有与受保护的修饰符 默认为 public class Animal { public name:string; public move(distance:number){ console.log(`move ${distance}`); } } 私有 private 当成员被标记为private时，它就不能在声明它的类外部访问。class Animal { private name:string; constructor(thename:number){ this.name = thename; } } new Animal('Cat').name // error name是私有的 类型兼容：如果其中一个类型里包含一个private成员，那么只有当另一个类型中也存在这样一个private成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。protected也适用这个规则。 class Animal { private name: string; constructor(theName: string) { this.name = theName; } } class Rhino extends Animal { constructor() { super(\"Rhino\"); } } class Employee { private name: string; constructor(theName: string) { this.name = theName; } } let animal = new Animal(\"Goat\"); let rhino = new Rhino(); let employee = new Employee(\"Bob\"); animal = rhino; animal = employee; // 错误: Animal 与 Employee 不兼容. 被保护 protected 与private修饰符的行为相似，但protected成员在派生类中仍然可以访问 class Person { protected name: string; constructor(name: string) { this.name = name; } } class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); // protected属性name在派生类中还可使用 this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(\"Howard\", \"Sales\"); console.log(howard.getElevatorPitch()); console.log(howard.name); // 错误 class Person { protected name: string; protected constructor(theName: string) { this.name = theName; } // 不能被实力话，但是可以继承 } // Employee 能够继承 Person class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; } } let howard = new Employee(\"Howard\", \"Sales\"); let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. readonly 修饰符 将属性设置为只读，只读属性必须在声明时或构造函数里被初始化。class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; } } let dad = new Octopus(\"Man with the 8 strong legs\"); dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性 参数属性通过给构造函数添加一个访问限定符来声明。使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说是一样的。class Animal { constructor(private name: string) { } move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } 存取器 typeScript 支持通过 getter/setter 来截取对对象成员的访问。 注意：只带有 get ，不带有 set 的存取器自动被推断为 readonly。 class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { this._fullName = newName; } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); } 静态属性 存在于类本身上面而不是类的实例上，每个实例想要访问，都需使用类名访问。 class Grid { static origin = {x: 0, y: 0}; calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; } constructor (public scale: number) { } } let grid1 = new Grid(1.0); // 1x scale let grid2 = new Grid(5.0); // 5x scale console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); 抽象类 抽象类作为其他派生类的基类使用，一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。abstract关键字用来定义抽象类和抽象类内部定义的抽象方法。abstract class Animal { abstract makeSound(): void; move(): void { console.log(\"roaming the earth...\"); } } 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现，抽象方法的语法与接口方法相似。两者都是定义方法签名饭不包含方法体。然而，抽象方法必须包含abstract关键字且可以包含访问修饰符。 abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现 } class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); } } let department: Department; // 允许创建一个对抽象类型的引用 department = new Department(); // 错误: 不能创建一个抽象类的实例 department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值 department.printName(); department.printMeeting(); department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧 类定义会创建：类的实例类型和一个构造函数。 构造函数 当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的实例的类型。 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter: Greeter; greeter = new Greeter(\"world\"); console.log(greeter.greet()); let greeterMaker: typeof Greeter = Greeter; // typeof Greeter 意为获取Greeter类的类型，而不是实例的类型 greeterMaker.standardGreeting = \"Hey there!\"; 把类当作接口使用 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类 class Point { x: number; y: number; } interface Point3d extends Point { z: number; } let point3d: Point3d = {x: 1, y: 2, z: 3}; "},"FrontEnd/TypeScript/enum.html":{"url":"FrontEnd/TypeScript/enum.html","title":"枚举","keywords":"","body":"枚举 使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。 数字枚举 默认从 0 开始，可指定 enum Response { No = 0, Yes = 1, } function respond(recipient: string, message: Response): void { // ... } respond(\"Princess Caroline\", Response.Yes) 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 enum Direction { Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\", }   由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 异构枚举 不建议使用【枚举可以混合字符串和数字成员】 enum BooleanLikeHeterogeneousEnum { No = 0, Yes = \"YES\", } 计算的和常量成员 每个枚举成员都带有一个值，它可以是常量或计算出来的。 当满足如下条件时，枚举成员被当作是常量： 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值0enum E { X } 它不带有初始化器且它之前的枚举成员是一个数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1。 enum E1 { X, Y, Z } enum E2 { A = 1, B, C } 枚举成员使用常量枚举表达式初始化。 常量枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符+, -, ~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符+, -, *, /, %, , >>, >>>, &, |, ^的操作对象。 若常量枚举表达式求值后为NaN或Infinity，则会在编译阶段报错。 enum FileAccess { // constant members None, Read = 1 联合枚举类型与枚举成员的类型 存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如：\"foo\"，\"bar\"，\"baz\"） 任何数字字面量（例如：1, 100） 应用了一元-符号的数字字面量（例如：-1, -100） 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。 首先，枚举成员成为了类型！ enum ShapeKind { Circle, Square, } interface Circle { kind: ShapeKind.Circle; radius: number; } interface Square { kind: ShapeKind.Square; sideLength: number; } let c: Circle = { kind: ShapeKind.Square, // ~~~~~~~~~~~~~~~~ Error! radius: 100, } 另一个变化是枚举类型本身变成了每个枚举成员的联合。 虽然我们还没有讨论联合类型，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如： enum E { Foo, Bar, } function f(x: E) { if (x !== E.Foo || x !== E.Bar) { // ~~~~~~~~~~~ // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'. } } 运行时的枚举 枚举是在运行时真正存在的对象 enum E { X, Y, Z } function f(obj: { X: number }) { return obj.X; } // Works, since 'E' has a property named 'X' which is a number. f(E); 反向映射 除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。[不会为字符串枚举成员生成反向映射] enum Enum { A } let a = Enum.A; let nameOfA = Enum[a]; // \"A\" // 转换js var Enum; (function (Enum) { Enum[Enum[\"A\"] = 0] = \"A\"; })(Enum || (Enum = {})); var a = Enum.A; var nameOfA = Enum[a]; // \"A\" const 枚举 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。 const enum Directions { Up, Down, Left, Right } let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] // 生成代码 var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。 declare enum Enum { A = 1, B, C = 2 } "},"FrontEnd/TypeScript/function.html":{"url":"FrontEnd/TypeScript/function.html","title":"函数","keywords":"","body":"函数 TypeScript函数可以创建有名字的函数和匿名函数。 函数类型 为函数定义类型 function add(x:number,y:number):number { return x+y; } let myAdd = function(x:number,y:number):number { return x+y; } 书写完整函数类型 // 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 let myAdd:{x:number,y:number} => number = function(x:number,y:number):number { return x+y; }； // 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 let myAdd: (baseValue: number, increment: number) => number = function(x: number, y: number): number { return x + y; }; 推断类型 在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型： // myAdd has the full function type let myAdd = function(x: number, y: number): number { return x + y; }; // The parameters `x` and `y` have the type number let myAdd: (baseValue: number, increment: number) => number = function(x, y) { return x + y; }; 可选参数和默认参数 TypeScript里的每个函数参数都是必须的 function buildName(firstName: string, lastName: string) { return firstName + \" \" + lastName; } let result1 = buildName(\"Bob\"); // error, 参数缺失 let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数溢出 let result3 = buildName(\"Bob\", \"Adams\"); // success 参数符合 可选参数功能（参数名旁使用?）可选参数必须跟在必须参数后面 function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \" \" + lastName; else return firstName; } let result1 = buildName(\"Bob\"); // success let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数溢出 let result3 = buildName(\"Bob\", \"Adams\"); // ah, 参数符合 默认值 同ES6 function buildName(firstName: string, lastName:string = \"Smith\") { return firstName + \" \" + lastName; } let result1 = buildName(\"Bob\"); // success \"Bob Smith\" let result2 = buildName(\"Bob\", undefined); // success \"Bob Smith\" let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数溢出 let result4 = buildName(\"Bob\", \"Adams\"); // success \"Bob Smith\" 剩余参数 在JavaScript里，你可以使用arguments来访问所有传入的参数。在TypeScript里，你可以把所有参数收集到一个变量里 function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \"); } let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); "},"FrontEnd/TypeScript/generic.html":{"url":"FrontEnd/TypeScript/generic.html","title":"泛型","keywords":"","body":"泛型 是一种特殊的变量，只用于标识类型而不是值 泛型函数 function identity(arg: T): T { return arg; } // 使用 let output = identity(\"myString\"); let output = identity(\"myString\"); // 利用类型推论-确定 T 类型 使用泛型变量 编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。 function loggingIdentity(arg: T): T { console.log(arg.length); // Error: T 没有 .length 属性 return arg; } function loggingIdentity(arg: T[]): T[] { // T类型的数组 console.log(arg.length); // 数组有 .length 属性 return arg; } 泛型类型 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面（），像函数声明一样： function identity(arg: T): T { return arg; } let myIdentity: (arg: T) => T = identity; 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。 function identity(arg: T): T { return arg; } let myIdentity: (arg: U) => U = identity; 我们还可以使用带有调用签名的对象字面量来定义泛型函数 function identity(arg: T): T { return arg; } let myIdentity: {(arg: T): T} = identity; 泛型接口 interface GenericIdentityFn { (arg: T): T; } function identity(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 把泛型参数当作整个接口的一个参数 interface GenericIdentityFn { (arg: T): T; } function identity(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 泛型类 泛型类使用（<>）括起泛型类型，跟在类名后面。【泛型类指的是实例部分的类型，所以类的静态属性不能使用泛型类型】 class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; } let myGenericNumber = new GenericNumber(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; }; 泛型约束 interface Lengthwise { length: number; } // 限制泛型数据必需含有 .length 属性 function loggingIdentity(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg; } 在泛型约束中使用类型的参数 // 约束获取对象时，key 值必需存在于对象上 function getProperty(obj: T, key: K) { return obj[key]; } let x = { a: 1, b: 2, c: 3, d: 4 }; getProperty(x, \"a\"); // okay getProperty(x, \"m\"); // error: x 没有 'm' 的 key 在泛型里使用类类型 待补充 "},"FrontEnd/TypeScript/interface.html":{"url":"FrontEnd/TypeScript/interface.html","title":"接口","keywords":"","body":"接口 interface - 只声明成员方法，不做实现 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 初识 类型检查器会查看fn的调用，参数要求必需一个为string类型的label。 只检查必需属性是否存在，并且类型是否匹配。类型检查器不会检查属性顺序 let fn = (params: { label:string } ) => { console.log(params.label); } interface paramsLimit { label:string, } // paramsLimit 接口相当于名字，描述要求。 fn = (params:paramsLimit) => { console.log(params.label); } 可选属性 接口属性不全是必需 interface paramsLimit { label?:string; title?:string; } let fn = (parasm:paramsList):{} => { console.log(params); } fn(); // success fn({ label:'2' }); // success fn({ label:'2', title:'1' }); // success 只读属性 readonly 对象属性只能在对象创建时修改值 interface ReadOnly { readonly title:string; readonly num:number; } let readonlyObject:ReadOnly = { title:'title', num:3, } readonlyObject.title = 'title2'; // error typeScript 具有 ReadonlyArray 类型，与 Array 相似,只是把所有可变的方法去掉了 let a:number[] = [1,2,4]; let ro:ReadonlyArray = a; ro[0] = 1; // error ro.push(2); // error let b = ro; // success 可使用断言 a = ro; // error a = ro as number[]; // success a = ro; // success JSX中不可使用 额外的属性检查 SquareConfig 可以有任意数量的属性 interface SquareConfig { label?:string; title?:string; [propname:string]:any } let fn:void = (data:SquareConfig) => {} fn({color:2}) // success; 赋值给其他变量 let a = {colo:2,title:2} fn(a); // success a不需经过额外属性检查 和SquareConfig有相同属性时可用; let b = {colo:3} fn(b); // error 函数类型 定义调用签名：定义参数列表和返回值类型的函数定义 interface SearchFn { ( source:string, title:string ): number; } let fn:SearchFn = (source:string,title:string) => true // 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 fn = ({a:string,b:string}):boolean{} // error boolean不符合number 可索引的类型 可索引类型需具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型 interface StringArray { [ index:number ]:string; } let a:StringArray = ['1','2','3']; a[1]; // '2' 类类型 实现接口 接口描述了类的公共部分，而不是公共和私有两部分。它不会帮你检查类是否具有某些私有成员 interface ClockInterface { currentTime: Date; setTime(d: Date): void; } class Clock implements ClockInterface { // implements 实现的意思 currentTime: Date = new Date(); setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 类静态部分和实例部分的区别 类具有两个类型：静态部分的类型和实例的类型 继承接口 和类一样，接口也可以相互继承。 // 继承单个接口 interface Shape { color: string; } interface Square extends Shape { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; // 继承多个接口 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0; 混合类型 先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number): string { return '' }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // Error: Property 'state' is missing in type 'Image'. class Image implements SelectableControl { select() { } } class Location { }   在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。   在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上，SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。 "},"FrontEnd/AJAX/ajax.html":{"url":"FrontEnd/AJAX/ajax.html","title":"AJAX","keywords":"","body":"AJAX [ Asynchronous Javascript And XML - 异步 Javascript 和 XML] [ XMLHttpRequest 对象（核心）, JavaScript/DOM, CSS, HTML] 允许浏览器与服务器通信而无需刷新当前页面的技术 JSON[JavaScript Object Notation] JavaScript对象注解 JSON和XML被用来在AJAX模型中打包信息 XMLHttpRequest(XHR) 构造方法 XMLHttpRequest(); 构造函数初始化一个XMLHttpRequest对象，必须在多有其他方法被调用前调用构造函数 属性 XMLHttpRequest.onreadystatechange 当readyState属性变化时调用的EvevntHandler。 XMLHttpRequest.readyState[只读] 0 ：初始化状态 1 ：open()方法已调用，但是send()方法未调用，请求还没有被发送 2 ：send()方法被调用，Http请求方法已发送到Web服务器，未接收到响应 3 ：所有响应头部都已经接收到，响应体开始接收但未完成 4 ：HTTP响应已完全接收。 XMLHttpRequest.response[只读] 返回的数据类型，取决于 XMLHttpRrquest.responseType 的值，其中包含响应体 body。 XMLHttpRequest.responseText[只读] - "},"FrontEnd/Git/":{"url":"FrontEnd/Git/","title":"Git","keywords":"","body":"git "},"FrontEnd/Git/alias.html":{"url":"FrontEnd/Git/alias.html","title":"Git 别名","keywords":"","body":"Git 别名 配置别名 git config --global alias.[ new-name ] [ command-name ] "},"FrontEnd/Git/branch.html":{"url":"FrontEnd/Git/branch.html","title":"分支","keywords":"","body":"分支(本质：指向提交对象的可变指针) git commit 提交时，Git会先计算每一个子目录的校验和，然后在Git仓库中这些校验和保存为树对象，随后创建一个提交对象（包含指向这个树对象的指针）。Git可以在需要的时候重现保存的快照。 Git 仓库有五个对象：三个 blob 对象（保存者文件快照片），一个树对象（记录着目录结构和 blob 对象索引），以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。 分支创建 git branch [ branch-name ] 创建分支，但未切换到新创建的分支 git branch [ branch-name ] -b 创建分支，并切换到新创建的分支 在当前所在的提交对象上创建一个指针 创建一个新分支，但不会自动切换到新分支去。即 HEAD 指针指向当前所在分支，并未指向新创建的分支 特殊指针HEAD指向房前所在的本地分支 分支切换 git checkout [ branch-name ] HEAD指针指向 branch-name 分支 分支删除 git branch -d [ branch-name ] 分支合并 git merge [ branch-name(source) ] 如若有冲突时，Git会尝试自动合并，合并不成功时，需手动合并，合并完成之后使用 git add 将冲突文件状态变更为已解决，之后可 git commit 提交合并结果 删除远程分支 git push [ remote-name ] --delete [ branch-name ] 变基 rebase 命令将提交到某一个分支的所有数据都移至另一个分支上 git rebase [ rebase-target-branch-name ] [ source-branch-name ] source-branch-name变基在rebase-target-branch-name分支上，使得rebase-target-branch-name分支提交记录直接前进 命令 git branch 查看分支列表 git branch -v 查看每个分支最后一次提交 git branch -vv 查看所有跟踪分支 git branch -b [ branch-name ] [ remote-branch-name ] 新建分支并设置远程跟踪分支 git branch -u [ remote-branch-name] 修改远程跟踪分支 git branch --merge 查看哪些分支已经合并到当前分支 git branch --no-merge 查看哪些分支未合并到当前分支 git branch -d [ branch-name ] 删除分支 git branch -D [ branch-name ] 强制删除分支 git fetch 从服务器上抓取本地没有的数据，不会修改工作目录中的内容，只会获取数据让你合并。 git pull = git fetch + git merge "},"FrontEnd/Git/hooks.html":{"url":"FrontEnd/Git/hooks.html","title":"Git Hooks","keywords":"","body":"Git Hooks Git 能在特定的重要动作发生时触发自定义脚本。钩子存储在 Git目录下的hooks子目录中。也是大部分项目中的 .git/hooks。把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。 客户端hooks 克隆某个版本库时，它的客户端钩子 并不 随同复制。 如果需要靠这些脚本来强制维持某种策略，建议你在服务器端实现这一功能。 提交工作流钩子 pre-commit 在键入提交信息前运行，用以检查即将提交的快照。如果该钩子以非零值退出，Git 将放弃此次提交，不过可以使用 git commit --no-verify 来绕过检查 #!/bin/bash # 如果在commit时有未添加到暂存区的文件，拒绝提交 diff=$(git diff) if [[ $diff !=0 ]];then echo \"some files is changed but not add to stash, git commit denied\" exit 1 fi # 读取git暂存区的.js 和 .vue文件 files=$(git diff --cached --name-only | grep -E '\\.js$|\\.vue$') # 在控制台打印文件列表 echo $files # Prevent ESLint help message if no files matched # 如果文件列表为空，退出执行环境，继续执行commit操作 if [[ $files = \"\" ]] ; then exit 0 fi failed=0 # 循环文件列表 for file in ${files}; do # 判断文件是否存在(-e 表示 exists) if [ ! -e $file ] ; then continue fi # 在控制台打印该文件的eslint检验结果，如果通过，则返回空 git show :$file | ./node_modules/.bin/eslint $file --color --fix # 文件未通过eslint检验，标记为失败 if [[ $? != 0 ]] ; then failed=1 fi done; # 有文件未通过检验，退出执行环境，中断commit操作 if [[ $failed != 0 ]] ; then echo \"❌ ESLint failed, git commit denied\" exit $failed fi # 通过测试发现，如果通过 yarn add 的方式安装 eslint , babel-eslint 的话，这句代码将会报错: # git show :$file | ./node_modules/.bin/eslint $file --color --fix # 只用用npm重新安装上面提到的一些包，才能在 ./node_modules/.bin 目录下找到eslint prepare-commit-msg 在启动提交信息编辑器之前，默认信息被创建之后运行。允许编辑提交者所看到的默认信息，该钩子接收一些选项：存有当前提交信息的文件路径，提交类型和修补提交的提交的 SHA-1 校验。对哪些会自动产生默认信息的提交，可以结合模版来使用，动态插入信息。 commit-msg 钩子接收一个参数，即存有当前提交信息的临时文件的路径。如果钩子以非零值退出，Git 将放弃提交，可以用来在提交通过前校验项目状态或提交信息。 post-commit 钩子在整个提交过程完成后运行，不接收任何参数，但可以通过运行 git log -1 HEAD 来获得最后一次的提交信息，该钩子一般用于通知之类的事情。 电子邮件工作流钩子 钩子均由 git am 命令调用。 applypacth-msg 接收单个参数：包含请求合并信息的临时文件的名字。如果脚本返回非零值，Git 将放弃该补丁。可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。 pre-applypatch 运行于应用补丁之后，产生提交之前，可以用于在提交前检查快照，运行检测或检查工作区，如果未通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。 post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子，可以用于结果通知，但没办法用它停止打补丁的过程。 其他钩子 pre-rebase 钩子运行于变基之前，以非零值退出可以中止变基的过程。 可以用来禁止对已经推送的提交变基 post-rewrite 钩子被那些会替换提交记录的命令调用，比如 git commit --amend 和 git rebase（不过不包括 git filter-branch）。 唯一的参数是触发重写的命令名，同时从标准输入中接受一系列重写的提交记录。 这个钩子的用途很大程度上跟 post-checkout 和 post-merge 差不多 post-checkout 在 git checkout 成功运行后，post-checkout 钩子会被调用,可以用它调整工作目录。 其中包括放入大的二进制文件、自动生成文档或进行其他类似这样的操作。 post-merge 在 git merge 成功运行后，post-merge 钩子会被调用。 你可以用它恢复 Git 无法跟踪的工作区数据，比如权限数据。 这个钩子也可以用来验证某些在 Git 控制之外的文件是否存在，这样你就能在工作区改变时，把这些文件复制进来。 pre-push pre-push 钩子会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。 它接受远程分支的名字和位置作为参数，同时从标准输入中读取一系列待更新的引用。 你可以在推送开始之前，用它验证对引用的更新操作（一个非零的退出码将终止推送过程）。 pre-auto-gc Git 的一些日常操作在运行时，偶尔会调用 git gc --auto 进行垃圾回收。 pre-auto-gc 钩子会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。 服务器端hooks 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息 pre-receive 最先被调用的脚本。它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。 update 会为每一个准备更新的分支各运行一次。假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。 post-receive 在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户.它接受与 pre-receive 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统 "},"FrontEnd/Git/remote.html":{"url":"FrontEnd/Git/remote.html","title":"远程仓库","keywords":"","body":"远程仓库 添加远程仓库 git remote add 从远程仓库中抓取与拉取 git fetch [remote-name] git fetch 拉取数据到本地仓库，不会自动合并或修改当前分支。 git pull 会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支 git clone 命令会自动设置本地master分支跟踪克隆的远程仓库的 master 分支。 推送到远程分支 git push [ remote-name ] [ branch-name ] 查看远程分支 git remote show [ remote-name ] 远程仓库的移除与重命名 git remote rename [ old-remote-name ] [ new-remote-name ] git remote rm [ remote-name ] "},"FrontEnd/Git/tag.html":{"url":"FrontEnd/Git/tag.html","title":"打标签","keywords":"","body":"打标签 给历史中某个提交打上标签 查看标签 git show [ tag-name ] 列出标签 git tag git tag -l [ tag-name ] 列出指定tag 创建标签 轻量标签（特定提交的引用,本质：提交校验和存储到一个文件中） git tag [ tag-name ] 附注标签（存储在Git数据库中的一个完整对象，可以被校验。附带信息：打标签者名字，电子邮件地址，日期时间，标签信息） git tag -a [ tag-name ] -m [ tag-msg ] -m 指定了一条将会存储在标签中的信息 后期打标签 git tag -a [ tag-name ] [ 提交的校验和 ] 共享标签 git push [ remote-name ] [ tag-name ] 单个标签推送 git push [ remote-name ] --tags 推送所有不在远程仓库服务器上的标签 检出标签 git checkout -b [ branch-name ] [ tag-name ] 在特定的标签上创建一个新分支 "},"FrontEnd/Javascript/Babel/":{"url":"FrontEnd/Javascript/Babel/","title":"Babel","keywords":"","body":"Babel "},"FrontEnd/Javascript/npm/":{"url":"FrontEnd/Javascript/npm/","title":"npm","keywords":"","body":"npm 包发布 "},"FrontEnd/Javascript/npm/npm_issue.html":{"url":"FrontEnd/Javascript/npm/npm_issue.html","title":"npm 包发布","keywords":"","body":""},"FrontEnd/Javascript/webpack/":{"url":"FrontEnd/Javascript/webpack/","title":"webpack","keywords":"","body":"webpack "},"FrontEnd/Javascript/webpack/package.html":{"url":"FrontEnd/Javascript/webpack/package.html","title":"打包原理","keywords":"","body":"打包原理 "},"FrontEnd/React/":{"url":"FrontEnd/React/","title":"React","keywords":"","body":"React "},"FrontEnd/React/life.html":{"url":"FrontEnd/React/life.html","title":"生命周期","keywords":"","body":"生命周期 16.4 16.3 "},"Net/Http&Https/":{"url":"Net/Http&Https/","title":"Http&Https","keywords":"","body":"http&https "},"Net/Http&Https/CORS.html":{"url":"Net/Http&Https/CORS.html","title":"CORS","keywords":"","body":"HTTP 访问控制（CORS） OPTIONS 预检 不触发 OPTIONS 预检 简单请求 使用 GET,HEAD,POST 请求 设置了对CORS安全的首部字段集合标准外字段 Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width Content-Type 值设置要求以外的值 text/plain multiple/form-data application/x-www-form-urlencoded 请求中的任意 XMLHttpRequest.upload 对象均没有注册任何事件监听器 请求中没有使用 ReadableStream 对象 使用 CORS 首部字段处理跨域权限 预检请求 需预检的请求'要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求 预检请求于重定向 大多数浏览器不支持针对预检请求的重定向，如果预检请求发生了重定向，浏览器将报告错误 附带身份凭证的请求 可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。对于 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送 需设置 withCredentials 字段为true但如果 服务器响应中未携带 Access-Control-Allow-Credentials:true 浏览器将不会把响应内容返回给请求的发送者 附带身份凭证的请求失败 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin： 。原因在于请求的首部携带了 cookie 信息，返回 '' 请求将失败 HTTP 请求首部字段 Origin: 表明预检请求或实际请求的源站 Access-Control-Request-Method：将实际请求所使用的 HTTP 方法告诉服务器。 Access-Control-Request-Headers：将实际请求所携带的首部字段告诉服务器。 "},"Net/Http&Https/https.html":{"url":"Net/Http&Https/https.html","title":"Https","keywords":"","body":"HTTP & HTTPS HTTPS = HTTP + 数据加密 + 完整性校验 + 身份验证HTTPS = HTTP + SSL/TLS 数据加密 对称加密 介绍： 同一个密钥可以同时用来加密和解密 实现： 消息发送方需要将明文数据使用密钥加密发送。 接收方接收到密文后，通过密钥解密数据，获取明文数据 优点： 加密速度快，加密效率高 算法公开 计算量小 缺点： 数据传送前，发送方和接收方必须商定好密钥，然后使双方都能 缺点： 需要把密钥安全传递到解密方，存在安全问题。 算法 常用的单向加密算法： DES(Data Encryption Standard):数据加密标准，速度较快，适用于加密大量数据的场合。 3DES(Triole DES):是基于DES，对一块数据用三个不同的密钥进行三次加密，强度高 AES(Advanced Encryption Standard):高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128，192，256，512位密钥的加密 算法特征： 加密方和解密方使用同一个密钥 加密解密速度比较快，适合数据比较长时使用 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦 非对称加密 介绍： 需要两个密钥来进行加密和解密【公钥（public key），密钥（private key）】 实现： 发送方和接收方均生成两个密钥，公钥公开给对方，发送消息时，发送方使用对方的公钥对明文数据进行加密，接收方使用对应的密钥对数据解密。 密钥分发 对称加密： 如果 A 和 B 各自有一个到达第三方 C 的加密链路，C 能够在加密链路上分别传递新密钥给 A 和 B。---【Kerberos】 需要一个密钥分发中心（key distribution center KDC），KDC判断哪些系统或主机允许互相通信，当两个系统或主机被允许建立连接时，KDC就为这条连接提供一个唯一的一次性会话密钥（session key）。 "},"Net/CDN/cdn.html":{"url":"Net/CDN/cdn.html","title":"CDN","keywords":"","body":"CDN 内容分发网络 实时根据网络流量和各节点的链接，负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。解决Internet网络拥挤状况，提高用户访问网站的响应速度。 组成 分发服务系统 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标 负载均衡系统 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本 地负载均衡（SLB）。GSLB主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。SLB主要负 责节点内部的设备负载均衡 运营管理系统 分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。 使用 当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。 CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。 用户向CDN的全局负载均衡设备发起内容URL访问请求。 CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。 全局负载均衡设备把服务器的IP地址返回给用户 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 优点 本地 Cache 加速，加快访问速度 镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量 远程加速，自动选择cache服务器 带宽优化，分担网络流量，减轻压力 集群抗攻击 节约成本 "},"Net/DNS/dns.html":{"url":"Net/DNS/dns.html","title":"DNS","keywords":"","body":"DNS 域名解析系统：可进行域名与IP地址的转换书写域名：最低级开始直至顶级域名DNS查询或解析域名：从顶级域名开始至最低级域名 域名 即 DomainName，由英文字母（不区分大小写），阿拉伯数字，及‘-’组成的字符。 分为主体和后缀两部分，通过‘.’分割。 后缀：默认空白 命名空间 Root 根域名（.） 顶级域名 地区顶级域名 类别顶级域名 新增顶级域名 二级域名（.com） 子域名：下一层为上一层的子域 DNS 安全问题 DNS 域名劫持 修改了DNS的解析结果 DNS 污染 不经过DNS服务器，返回错误信息 DOS 攻击 故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃。 DDOS攻击 个人黑客没有能占全部带宽的网络，所以开发了分布式攻击，集合其他更多的网络带宽来同时对一个目标机发出大量攻击请求 可能造成域名解析瘫痪 DNS 优化 DNS prefetching 浏览器先尝试解析后在缓存 服务器响应设置X-DNS-Prefetch-Control：on启动与解析 特定域名预解析 域名收敛 减少DNS的请求 HTTPDNS 基于Http协议向HTTPDNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免运营商的域名劫持和进行精准调度。 客户端直接访问HttpDNS接口，获取业务在域名配置管理系统上配置的访问延迟最优的IP。（基于容灾考虑，还是保留次选使用运营商LocalDNS解析域名的方式） 客户端向获取到的IP后就向直接往此IP发送业务协议请求。以Http请求为例，通过在header中指定host字段，向HttpDNS返回的IP发送标准的Http请求即可。 "},"ServerEnd/script/":{"url":"ServerEnd/script/","title":"脚本","keywords":"","body":"脚本语言 "},"ServerEnd/script/Bash/":{"url":"ServerEnd/script/Bash/","title":"Bash","keywords":"","body":"Bash Bash是一个命令处理器，通常运行于文本窗口中，并能执行用户直接输入的命令。Bash还能从文件中读取命令，这样的文件称为脚本。和其他Unix shell 一样，它支持文件名替换（通配符匹配）、管道、here文档、命令替换、变量，以及条件判断和循环遍历的结构控制语句。包括关键字、语法在内的基本特性全部是从sh借鉴过来的。其他特性，例如历史命令，是从csh和ksh借鉴而来。总的来说，Bash虽然是一个满足POSIX规范的shell，但有很多扩展。 "},"ServerEnd/linux/":{"url":"ServerEnd/linux/","title":"linux","keywords":"","body":"linux 相关知识 "},"ServerEnd/linux/order.html":{"url":"ServerEnd/linux/order.html","title":"命令","keywords":"","body":"命令记录 nohup XXXXX & nohup node node.js & nohup: 忽略输入并把输出追加到\"nohup.out\" => 提示：后台执行程序的输出都被重定向到nohup.out文件 nohup node node.js >/dev/null & nohup: 忽略输入重定向错误到标准输出端 =>Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪 nohup node node.js >/dev/null 2>&1 & 2>&1 将错误信息重定向到标准输出 如果希望服务始终运行，则需使用任意命令回到初始页，并通过exit退出。 "},"ServerEnd/nginx/":{"url":"ServerEnd/nginx/","title":"nginx","keywords":"","body":"nginx web 服务器 相较于 Apache 优点 轻量级 异步非阻塞，高并发 内存消耗少 开源 安装 使用yum 遵照官网进行安装 Yum（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。基於 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 sudo yum install yum-utils 设置 yum 源 [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 下载 nginx yum install nginx 使用 nginx 默认配置为 /etc/nginx/nginx.conf 在默认配置中 include 了 同级目录 /etc/nginx/conf.d 下所有配置. which server block is used for a given request. /etc/nginx/nginx.conf user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; gzip on; gzip_types text/css application/javascript; include /etc/nginx/conf.d/*.conf; } /etc/nginx/conf.d/default.conf; server { listen 80; // 监听端口 server_name localhost; // #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } /etc/nginx/conf.d/book.conf; server{ listen 8001; # 监听的端口号 server_name localhost; root /home/gitbook/_book; # 文件路径 index index.html; } 负载均衡 upstream 模块 /etc/nginx/nginx.conf ... upstream backEnd { // backEnd 类似变量值，会赋值均衡后的指向 server xxx.xx.xx.xx:8002 server xxx.xx.xx.xx:8003 } ... 本地模拟时通过不同接口模拟均衡 server { listen 80; location / { proxy_pass http://backend; } } server { listen 8002; server_name localname; root xx/xxx/xx index index.html } "},"Arithmetic/":{"url":"Arithmetic/","title":"算法","keywords":"","body":"算法 "},"Code/":{"url":"Code/","title":"代码","keywords":"","body":"代码积累 "},"Code/tree.html":{"url":"Code/tree.html","title":"树&遍历","keywords":"","body":"树 & 遍历 const Node = function (key) { this.key = key; this.left = null; this.right = null; }; const Tree = function (treeList) { this.root = treeList ? this.insetList(treeList) : null; }; // desc 插入节点 Tree.prototype.insertNode = function (node, newNode) { if (newNode.key node.key) && node.right !== null) { return this.findNode(node.right, key); } else { return -1; } } } else { return -1; } }; // desc 移除节点 Tree.prototype.removeNode = function (node, key) { if (!node) { return null; } let delNode = node; if (delNode.key === key) { if (delNode.left && delNode.right) { const rightNodeMin = this.findMinNode(delNode.right); delNode.key = rightNodeMin.key; delNode.right = this.removeNode(delNode.right,rightNodeMin.key); } else if (delNode.left) { delNode = delNode.left; } else if (delNode.right) { delNode = delNode.right; } else { delNode = null; } } else if (key { list.push(node.key); }); return list; }; // desc 对外使用API - 先序遍历 Tree.prototype.preQuery = function (callback) { const list = []; this.preQueryNode(this.root, callback ? callback : (node) => { list.push(node.key); }) return list; }; // desc 对外使用API - 后序遍历 Tree.prototype.lastQuery = function (callback) { const list = []; this.lastQueryNode(this.root, callback ? callback : (node) => { list.push(node.key); }) return list; }; // desc 对外使用API - 数组插入 Tree.prototype.insetList = function (list) { list.forEach((key) => { this.insert(key); }) }; // desc 对外使用API - 查找节点 Tree.prototype.find = function (key) { return this.findNode(this.root, key); }; // desc 对外使用API - 查找最小节点 Tree.prototype.min = function () { return this.findMinNode(this.root); }; // desc 对外使用API - 查找最大节点 Tree.prototype.max = function () { return this.findMaxNode(this.root); }; const tree = new Tree(); // tree.insetList([10, 5, 1, 9, 7, 16, 12, 20, 15, 18, 22]); tree.insetList([10, 5, 1, 9, 7, 16, 12, 20, 15, 18, 17,19,22,21,24]) "}}